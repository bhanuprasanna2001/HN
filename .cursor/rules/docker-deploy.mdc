---
globs: infra/**/*.{yml,yaml,Dockerfile}, **/Dockerfile, docker-compose*.yml
---

# Docker + Deployment Rules

## Local Development: Docker Compose
- `docker-compose.yml` is the **single command** to run the full stack locally
- Services:
  1. `trustops-backend` — FastAPI app (port 8000)
  2. `trustops-frontend` — Nginx serving React SPA (port 3000)
  3. `trustops-redis` — Redis Stack (port 6379, RedisInsight on 8001)
  4. `trustops-otel-collector` — OTel Collector (port 4317 gRPC, 4318 HTTP)
  5. `trustops-prometheus` — Prometheus (port 9090)
  6. `trustops-grafana` — Grafana (port 3001)
- Additional dev compose (`docker-compose.dev.yml`) adds:
  - Hot reload for backend (volume mount + uvicorn --reload)
  - Vite dev server instead of nginx for frontend
  - RedisInsight UI for debugging

## Dockerfiles

### Backend Dockerfile (`backend/Dockerfile`)
- Multi-stage build: builder + runtime
- Base: `python:3.11-slim`
- Install dependencies from pyproject.toml / requirements.txt
- Copy app code
- Expose port 8000
- CMD: `uvicorn app.main:app --host 0.0.0.0 --port 8000`
- Health check: `curl -f http://localhost:8000/health`
- Keep image < 500MB

### Frontend Dockerfile (`frontend/Dockerfile`)
- Multi-stage: node build + nginx runtime
- Stage 1: `node:20-alpine` — install deps, run `npm run build`
- Stage 2: `nginx:alpine` — copy build output + custom nginx.conf
- nginx.conf handles SPA routing (fallback to index.html)
- Expose port 80
- Keep image < 50MB

## Environment Variables
- All services read from `.env` file (docker-compose `env_file` directive)
- Template in `.env.example` (committed to repo)
- Actual `.env` is gitignored
- Required variables:
  ```
  # LLM
  TRUSTOPS_LLM_MODEL=gpt-4o-mini
  TRUSTOPS_LLM_API_KEY=sk-...
  TRUSTOPS_EMBEDDING_MODEL=text-embedding-3-small

  # Redis
  TRUSTOPS_REDIS_URL=redis://trustops-redis:6379

  # OTel
  TRUSTOPS_OTEL_ENDPOINT=http://trustops-otel-collector:4317

  # Frontend (no WebSocket URL — SSE uses the same REST base URL)
  VITE_API_BASE_URL=http://localhost:8000/api/v1
  VITE_GRAFANA_URL=http://localhost:3001
  ```

## Networking
- All services on a single Docker network (`trustops-net`)
- Backend connects to Redis via service name (`trustops-redis:6379`)
- Frontend proxies API requests to backend via nginx upstream
- Grafana accessible directly for dashboard embedding

## Volume Mounts
- Redis: persistent volume for data durability (`trustops-redis-data`)
- Grafana: provisioned dashboards from `infra/grafana/dashboards/`
- Prometheus: config from `infra/prometheus.yml`
- OTel Collector: config from `infra/otel-collector-config.yaml`
- Backend (dev only): source code mounted for hot reload

## Kubernetes (Minimal — for "runs anywhere" credibility)
- Keep it simple: basic manifests in `infra/k8s/`
- Deployments + Services for: backend, frontend, redis
- ConfigMaps for: OTel collector config, Prometheus config, Grafana dashboards
- Secrets for: API keys
- NO Helm charts, NO operators, NO Ingress controllers (keep it judge-friendly)
- Manifests should work with `kubectl apply -f infra/k8s/`

### K8s Probes (signals production hygiene — judges notice this)
Every Deployment must define:
- **Liveness probe**: Restart if stuck
  ```yaml
  livenessProbe:
    httpGet:
      path: /health
      port: 8000
    initialDelaySeconds: 10
    periodSeconds: 30
  ```
- **Readiness probe**: Accept traffic only when ready (Redis connected, models loaded)
  ```yaml
  readinessProbe:
    httpGet:
      path: /health
      port: 8000
    initialDelaySeconds: 5
    periodSeconds: 10
  ```
- **Startup probe**: Allow slow starts (embedding model warmup)
  ```yaml
  startupProbe:
    httpGet:
      path: /health
      port: 8000
    failureThreshold: 30
    periodSeconds: 5
  ```
- Backend `/health` endpoint must return:
  - 200 + `{"status": "ok", "redis": "connected"}` when fully ready
  - 503 + `{"status": "starting", "redis": "disconnected"}` during startup

## Build & Run Commands (Document in README)
```bash
# Full stack (production-like)
docker-compose up --build

# Dev mode (hot reload)
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up

# Data pipeline (one-off)
docker-compose run --rm trustops-backend python -m pipelines.ingest
docker-compose run --rm trustops-backend python -m pipelines.embed

# View logs
docker-compose logs -f trustops-backend
```

## Health Checks
- Backend: `GET /health` returns `{"status": "ok", "redis": "connected", "version": "..."}`
- Redis: `redis-cli ping`
- Frontend: nginx returns 200 on `/`
- All health checks configured in docker-compose for restart policies
